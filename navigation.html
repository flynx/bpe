<!DOCTYPE html>
<html>
<style>

.block {
	border: solid 2px transparent;
	width: fit-content;
}

/* indent... */
div.block div.block {
	margin-left: 2em;
}

.block:focus {
	border: solid 2px red;
}

</style>

<script>

// XXX might be a good idea to define a set of custom elements...
//			- generic elements
//				can define language structures...
//			- language-specific elements
// XXX select editable item content on focus...
// XXX test touch operation...

var focusSiblingOfClass = 
function(recur, direction, onFail=false){
	return function(target, focus=true){
		//var elem = target[direction]
		// if at non-block get first block...
		// XXX should be: "get first/last ..."
		var elem = !target.classList.contains('block') ?
			document.querySelector('.block')
			: target[direction]
		var prev
		// get next element...
		while(elem && !elem.classList.contains('block')){
			prev = elem
			elem = elem[direction] }
		// focus...
		elem && focus
			&& elem.focus() 
		// no elements found...
		!elem && onFail
			&& (elem = onFail.call(this, target))
		return elem 
			|| prev }}

// XXX there can be to two control schemes here:
//			- hierarchical (current)
//				follows element topology
//				fast
//				might not be obvious visually without diving into context
//			- visual
//		...which is better may also depend on topology, e.g. for the for 
//		loop example below the args can be on the same level as block or 
//		between the block and the loop (i.e. a-la attrs)...
var KEY_HANDLERS = {
	// XXX split actions and mappings...
	//		- rename current handlers...
	//		- map key to handler...

	ArrowUp: focusSiblingOfClass(
		'ArrowUp', 
		'previousElementSibling',
		// when at top elem in block select block...
		// XXX would be nice to wrap around on up -- focus last top-level block...
		function(target){
			return this.ArrowLeft(target) }),
	ArrowDown: focusSiblingOfClass(
		'ArrowDown', 
		'nextElementSibling',
		// when at last elem select next...
		function(target){
			return this.ArrowDown(
				this.ArrowLeft(target, false)) }),
	// XXX should this destingwisth orientations and topology???
	//	...i.e. move to left block and only after move up???
	// XXX whe reaching top most element, should we go up???
	ArrowLeft: focusSiblingOfClass('ArrowLeft', 'parentElement'),
	ArrowRight: function(target){
		var elem = target.querySelector('.block')
		elem ? 
			elem.focus()
			: (elem = this.ArrowDown(target))
		return elem
			|| target },
}

window.addEventListener('keydown', function(evt){
	// expand aliases...
	var handler = evt.key
	while(typeof(handler) == 'string'){
		handler = KEY_HANDLERS[handler] }
	// call the handler...
	handler
		&& handler.call(KEY_HANDLERS, evt.target) })

</script>

<body>

<i>Basic tab-navigation via built-in html mechanics...</i>

<hr>

<div class="block" tabindex=0>
	block
	<div class="block" tabindex=0>
		sub-block
	</div>
	<div class="block" tabindex=0>
		sub-block
	</div>
</div>

<hr>

<div class="block" tabindex=0>
	// 
	<span class="block" tabindex=0>
		not sure how atomic we should get, feels a bit too complicated...
	</span>
</div>
<div class="block" tabindex=0>
	for(
	<span class="block" tabindex=0>
		<span class="block" tabindex=0>
			var
			<span class="block" tabindex=0>
				<span class="block" tabindex=0>
					i
				</span>
				=
				<span class="block" tabindex=0>
					0
				</span>
			</span>
		</span>
	</span>;
	<span class="block" tabindex=0>
		<span class="block" tabindex=0>
			<span class="block" tabindex=0>
				i
			</span>
			&lt; 
			<span class="block" tabindex=0>
				10
			</span>
		</span>
	</span>;
	<span class="block" tabindex=0>
		<span class="block" tabindex=0>
			<span class="block" tabindex=0>
				i
			</span>
			++
		</span>
	</span>){
	<div class="block" tabindex=0>
		console.log(
			<span class="block" tabindex=0>
				'---'
			</span>,
			<span class="block" tabindex=0 contenteditable>
				i
			</span>)	
	</div>}
</div>


</body>
</html>
<!-- vim:set ts=4 sw=4 : -->
